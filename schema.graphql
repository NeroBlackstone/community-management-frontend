### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly


type Activity {
  content: String!
  createdAt: DateTime!
  id: ID!
  owner: User!
  place: String!
  reply: String
  startAt: DateTime!
  status: Status!
  title: String!
}

type ActivityConnection {
  aggregate: AggregateActivity!
  edges: [ActivityEdge!]!
  pageInfo: PageInfo!
}

input ActivityCreateInput {
  content: String!
  id: ID
  owner: UserCreateOneWithoutActivitiesInput!
  place: String!
  reply: String
  startAt: DateTime!
  status: Status!
  title: String!
}

input ActivityCreateManyWithoutOwnerInput {
  connect: [ActivityWhereUniqueInput!]
  create: [ActivityCreateWithoutOwnerInput!]
}

input ActivityCreateWithoutOwnerInput {
  content: String!
  id: ID
  place: String!
  reply: String
  startAt: DateTime!
  status: Status!
  title: String!
}

type ActivityEdge {
  cursor: String!
  node: Activity!
}

enum ActivityOrderByInput {
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  place_ASC
  place_DESC
  reply_ASC
  reply_DESC
  startAt_ASC
  startAt_DESC
  status_ASC
  status_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ActivityScalarWhereInput {
  AND: [ActivityScalarWhereInput!]
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [ActivityScalarWhereInput!]
  OR: [ActivityScalarWhereInput!]
  place: String
  place_contains: String
  place_ends_with: String
  place_gt: String
  place_gte: String
  place_in: [String!]
  place_lt: String
  place_lte: String
  place_not: String
  place_not_contains: String
  place_not_ends_with: String
  place_not_in: [String!]
  place_not_starts_with: String
  place_starts_with: String
  reply: String
  reply_contains: String
  reply_ends_with: String
  reply_gt: String
  reply_gte: String
  reply_in: [String!]
  reply_lt: String
  reply_lte: String
  reply_not: String
  reply_not_contains: String
  reply_not_ends_with: String
  reply_not_in: [String!]
  reply_not_starts_with: String
  reply_starts_with: String
  startAt: DateTime
  startAt_gt: DateTime
  startAt_gte: DateTime
  startAt_in: [DateTime!]
  startAt_lt: DateTime
  startAt_lte: DateTime
  startAt_not: DateTime
  startAt_not_in: [DateTime!]
  status: Status
  status_in: [Status!]
  status_not: Status
  status_not_in: [Status!]
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
}

input ActivityUpdateInput {
  content: String
  owner: UserUpdateOneRequiredWithoutActivitiesInput
  place: String
  reply: String
  startAt: DateTime
  status: Status
  title: String
}

input ActivityUpdateManyDataInput {
  content: String
  place: String
  reply: String
  startAt: DateTime
  status: Status
  title: String
}

input ActivityUpdateManyMutationInput {
  content: String
  place: String
  reply: String
  startAt: DateTime
  status: Status
  title: String
}

input ActivityUpdateManyWithoutOwnerInput {
  connect: [ActivityWhereUniqueInput!]
  create: [ActivityCreateWithoutOwnerInput!]
  delete: [ActivityWhereUniqueInput!]
  deleteMany: [ActivityScalarWhereInput!]
  disconnect: [ActivityWhereUniqueInput!]
  set: [ActivityWhereUniqueInput!]
  update: [ActivityUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [ActivityUpdateManyWithWhereNestedInput!]
  upsert: [ActivityUpsertWithWhereUniqueWithoutOwnerInput!]
}

input ActivityUpdateManyWithWhereNestedInput {
  data: ActivityUpdateManyDataInput!
  where: ActivityScalarWhereInput!
}

input ActivityUpdateWithoutOwnerDataInput {
  content: String
  place: String
  reply: String
  startAt: DateTime
  status: Status
  title: String
}

input ActivityUpdateWithWhereUniqueWithoutOwnerInput {
  data: ActivityUpdateWithoutOwnerDataInput!
  where: ActivityWhereUniqueInput!
}

input ActivityUpsertWithWhereUniqueWithoutOwnerInput {
  create: ActivityCreateWithoutOwnerInput!
  update: ActivityUpdateWithoutOwnerDataInput!
  where: ActivityWhereUniqueInput!
}

input ActivityWhereInput {
  AND: [ActivityWhereInput!]
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [ActivityWhereInput!]
  OR: [ActivityWhereInput!]
  owner: UserWhereInput
  place: String
  place_contains: String
  place_ends_with: String
  place_gt: String
  place_gte: String
  place_in: [String!]
  place_lt: String
  place_lte: String
  place_not: String
  place_not_contains: String
  place_not_ends_with: String
  place_not_in: [String!]
  place_not_starts_with: String
  place_starts_with: String
  reply: String
  reply_contains: String
  reply_ends_with: String
  reply_gt: String
  reply_gte: String
  reply_in: [String!]
  reply_lt: String
  reply_lte: String
  reply_not: String
  reply_not_contains: String
  reply_not_ends_with: String
  reply_not_in: [String!]
  reply_not_starts_with: String
  reply_starts_with: String
  startAt: DateTime
  startAt_gt: DateTime
  startAt_gte: DateTime
  startAt_in: [DateTime!]
  startAt_lt: DateTime
  startAt_lte: DateTime
  startAt_not: DateTime
  startAt_not_in: [DateTime!]
  status: Status
  status_in: [Status!]
  status_not: Status
  status_not_in: [Status!]
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
}

input ActivityWhereUniqueInput {
  id: ID
}

type Address {
  building: Int!
  id: ID!
  room: Int!
  unit: Int!
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]
}

type AddressConnection {
  aggregate: AggregateAddress!
  edges: [AddressEdge!]!
  pageInfo: PageInfo!
}

input AddressCreateInput {
  building: Int!
  id: ID
  room: Int!
  unit: Int!
  users: UserCreateManyWithoutAddressInput
}

input AddressCreateOneWithoutUsersInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutUsersInput
}

input AddressCreateWithoutUsersInput {
  building: Int!
  id: ID
  room: Int!
  unit: Int!
}

type AddressEdge {
  cursor: String!
  node: Address!
}

enum AddressOrderByInput {
  building_ASC
  building_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  room_ASC
  room_DESC
  unit_ASC
  unit_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input AddressUpdateInput {
  building: Int
  room: Int
  unit: Int
  users: UserUpdateManyWithoutAddressInput
}

input AddressUpdateManyMutationInput {
  building: Int
  room: Int
  unit: Int
}

input AddressUpdateOneWithoutUsersInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutUsersInput
  delete: Boolean
  disconnect: Boolean
  update: AddressUpdateWithoutUsersDataInput
  upsert: AddressUpsertWithoutUsersInput
}

input AddressUpdateWithoutUsersDataInput {
  building: Int
  room: Int
  unit: Int
}

input AddressUpsertWithoutUsersInput {
  create: AddressCreateWithoutUsersInput!
  update: AddressUpdateWithoutUsersDataInput!
}

input AddressWhereInput {
  AND: [AddressWhereInput!]
  building: Int
  building_gt: Int
  building_gte: Int
  building_in: [Int!]
  building_lt: Int
  building_lte: Int
  building_not: Int
  building_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  room: Int
  room_gt: Int
  room_gte: Int
  room_in: [Int!]
  room_lt: Int
  room_lte: Int
  room_not: Int
  room_not_in: [Int!]
  unit: Int
  unit_gt: Int
  unit_gte: Int
  unit_in: [Int!]
  unit_lt: Int
  unit_lte: Int
  unit_not: Int
  unit_not_in: [Int!]
  users_every: UserWhereInput
  users_none: UserWhereInput
  users_some: UserWhereInput
}

input AddressWhereUniqueInput {
  id: ID
}

type Advice {
  comments(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderByInput, skip: Int, where: CommentWhereInput): [Comment!]
  content: String!
  createdAt: DateTime!
  id: ID!
  owner: User!
  title: String!
}

type AdviceConnection {
  aggregate: AggregateAdvice!
  edges: [AdviceEdge!]!
  pageInfo: PageInfo!
}

input AdviceCreateInput {
  comments: CommentCreateManyWithoutAdviceInput
  content: String!
  id: ID
  owner: UserCreateOneWithoutAdvicesInput!
  title: String!
}

input AdviceCreateManyWithoutOwnerInput {
  connect: [AdviceWhereUniqueInput!]
  create: [AdviceCreateWithoutOwnerInput!]
}

input AdviceCreateOneWithoutCommentsInput {
  connect: AdviceWhereUniqueInput
  create: AdviceCreateWithoutCommentsInput
}

input AdviceCreateWithoutCommentsInput {
  content: String!
  id: ID
  owner: UserCreateOneWithoutAdvicesInput!
  title: String!
}

input AdviceCreateWithoutOwnerInput {
  comments: CommentCreateManyWithoutAdviceInput
  content: String!
  id: ID
  title: String!
}

type AdviceEdge {
  cursor: String!
  node: Advice!
}

enum AdviceOrderByInput {
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input AdviceScalarWhereInput {
  AND: [AdviceScalarWhereInput!]
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [AdviceScalarWhereInput!]
  OR: [AdviceScalarWhereInput!]
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
}

input AdviceUpdateInput {
  comments: CommentUpdateManyWithoutAdviceInput
  content: String
  owner: UserUpdateOneRequiredWithoutAdvicesInput
  title: String
}

input AdviceUpdateManyDataInput {
  content: String
  title: String
}

input AdviceUpdateManyMutationInput {
  content: String
  title: String
}

input AdviceUpdateManyWithoutOwnerInput {
  connect: [AdviceWhereUniqueInput!]
  create: [AdviceCreateWithoutOwnerInput!]
  delete: [AdviceWhereUniqueInput!]
  deleteMany: [AdviceScalarWhereInput!]
  disconnect: [AdviceWhereUniqueInput!]
  set: [AdviceWhereUniqueInput!]
  update: [AdviceUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [AdviceUpdateManyWithWhereNestedInput!]
  upsert: [AdviceUpsertWithWhereUniqueWithoutOwnerInput!]
}

input AdviceUpdateManyWithWhereNestedInput {
  data: AdviceUpdateManyDataInput!
  where: AdviceScalarWhereInput!
}

input AdviceUpdateOneWithoutCommentsInput {
  connect: AdviceWhereUniqueInput
  create: AdviceCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: AdviceUpdateWithoutCommentsDataInput
  upsert: AdviceUpsertWithoutCommentsInput
}

input AdviceUpdateWithoutCommentsDataInput {
  content: String
  owner: UserUpdateOneRequiredWithoutAdvicesInput
  title: String
}

input AdviceUpdateWithoutOwnerDataInput {
  comments: CommentUpdateManyWithoutAdviceInput
  content: String
  title: String
}

input AdviceUpdateWithWhereUniqueWithoutOwnerInput {
  data: AdviceUpdateWithoutOwnerDataInput!
  where: AdviceWhereUniqueInput!
}

input AdviceUpsertWithoutCommentsInput {
  create: AdviceCreateWithoutCommentsInput!
  update: AdviceUpdateWithoutCommentsDataInput!
}

input AdviceUpsertWithWhereUniqueWithoutOwnerInput {
  create: AdviceCreateWithoutOwnerInput!
  update: AdviceUpdateWithoutOwnerDataInput!
  where: AdviceWhereUniqueInput!
}

input AdviceWhereInput {
  AND: [AdviceWhereInput!]
  comments_every: CommentWhereInput
  comments_none: CommentWhereInput
  comments_some: CommentWhereInput
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [AdviceWhereInput!]
  OR: [AdviceWhereInput!]
  owner: UserWhereInput
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
}

input AdviceWhereUniqueInput {
  id: ID
}

type AggregateActivity {
  count: Int!
}

type AggregateAddress {
  count: Int!
}

type AggregateAdvice {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AuthPayload {
  token: String
  user: User
}

type BatchPayload {
  count: Long!
}

type Comment {
  advice: Advice
  content: String!
  createdAt: DateTime!
  id: ID!
  owner: User
}

type CommentConnection {
  aggregate: AggregateComment!
  edges: [CommentEdge!]!
  pageInfo: PageInfo!
}

input CommentCreateInput {
  advice: AdviceCreateOneWithoutCommentsInput
  content: String!
  id: ID
  owner: UserCreateOneWithoutCommentsInput
}

input CommentCreateManyWithoutAdviceInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutAdviceInput!]
}

input CommentCreateManyWithoutOwnerInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutOwnerInput!]
}

input CommentCreateWithoutAdviceInput {
  content: String!
  id: ID
  owner: UserCreateOneWithoutCommentsInput
}

input CommentCreateWithoutOwnerInput {
  advice: AdviceCreateOneWithoutCommentsInput
  content: String!
  id: ID
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

enum CommentOrderByInput {
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CommentPreviousValues {
  content: String!
  createdAt: DateTime!
  id: ID!
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  previousValues: CommentPreviousValues
  updatedFields: [String!]
}

input CommentUpdateInput {
  advice: AdviceUpdateOneWithoutCommentsInput
  content: String
  owner: UserUpdateOneWithoutCommentsInput
}

input CommentUpdateManyDataInput {
  content: String
}

input CommentUpdateManyMutationInput {
  content: String
}

input CommentUpdateManyWithoutAdviceInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutAdviceInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAdviceInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAdviceInput!]
}

input CommentUpdateManyWithoutOwnerInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutOwnerInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutOwnerInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  data: CommentUpdateManyDataInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateWithoutAdviceDataInput {
  content: String
  owner: UserUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutOwnerDataInput {
  advice: AdviceUpdateOneWithoutCommentsInput
  content: String
}

input CommentUpdateWithWhereUniqueWithoutAdviceInput {
  data: CommentUpdateWithoutAdviceDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutOwnerInput {
  data: CommentUpdateWithoutOwnerDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutAdviceInput {
  create: CommentCreateWithoutAdviceInput!
  update: CommentUpdateWithoutAdviceDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutOwnerInput {
  create: CommentCreateWithoutOwnerInput!
  update: CommentUpdateWithoutOwnerDataInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  advice: AdviceWhereInput
  AND: [CommentWhereInput!]
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  owner: UserWhereInput
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type File {
  encoding: String!
  fileId: String!
  filename: String!
  id: ID!
  mimetype: String!
  path: String!
}

type FileConnection {
  aggregate: AggregateFile!
  edges: [FileEdge!]!
  pageInfo: PageInfo!
}

input FileCreateInput {
  encoding: String!
  fileId: String!
  filename: String!
  id: ID
  mimetype: String!
  path: String!
}

type FileEdge {
  cursor: String!
  node: File!
}

enum FileOrderByInput {
  createdAt_ASC
  createdAt_DESC
  encoding_ASC
  encoding_DESC
  fileId_ASC
  fileId_DESC
  filename_ASC
  filename_DESC
  id_ASC
  id_DESC
  mimetype_ASC
  mimetype_DESC
  path_ASC
  path_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input FileUpdateInput {
  encoding: String
  fileId: String
  filename: String
  mimetype: String
  path: String
}

input FileUpdateManyMutationInput {
  encoding: String
  fileId: String
  filename: String
  mimetype: String
  path: String
}

input FileWhereInput {
  AND: [FileWhereInput!]
  encoding: String
  encoding_contains: String
  encoding_ends_with: String
  encoding_gt: String
  encoding_gte: String
  encoding_in: [String!]
  encoding_lt: String
  encoding_lte: String
  encoding_not: String
  encoding_not_contains: String
  encoding_not_ends_with: String
  encoding_not_in: [String!]
  encoding_not_starts_with: String
  encoding_starts_with: String
  fileId: String
  fileId_contains: String
  fileId_ends_with: String
  fileId_gt: String
  fileId_gte: String
  fileId_in: [String!]
  fileId_lt: String
  fileId_lte: String
  fileId_not: String
  fileId_not_contains: String
  fileId_not_ends_with: String
  fileId_not_in: [String!]
  fileId_not_starts_with: String
  fileId_starts_with: String
  filename: String
  filename_contains: String
  filename_ends_with: String
  filename_gt: String
  filename_gte: String
  filename_in: [String!]
  filename_lt: String
  filename_lte: String
  filename_not: String
  filename_not_contains: String
  filename_not_ends_with: String
  filename_not_in: [String!]
  filename_not_starts_with: String
  filename_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  mimetype: String
  mimetype_contains: String
  mimetype_ends_with: String
  mimetype_gt: String
  mimetype_gte: String
  mimetype_in: [String!]
  mimetype_lt: String
  mimetype_lte: String
  mimetype_not: String
  mimetype_not_contains: String
  mimetype_not_ends_with: String
  mimetype_not_in: [String!]
  mimetype_not_starts_with: String
  mimetype_starts_with: String
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  path: String
  path_contains: String
  path_ends_with: String
  path_gt: String
  path_gte: String
  path_in: [String!]
  path_lt: String
  path_lte: String
  path_not: String
  path_not_contains: String
  path_not_ends_with: String
  path_not_in: [String!]
  path_not_starts_with: String
  path_starts_with: String
}

input FileWhereUniqueInput {
  fileId: String
  id: ID
}

scalar Long

type Mutation {
  createActivity(data: ActivityCreateInput!): Activity!
  createAddress(data: AddressCreateInput!): Address!
  createAdvice(data: AdviceCreateInput!): Advice!
  createComment(data: CommentCreateInput!): Comment!
  createFile(data: FileCreateInput!): File!
  createResident(building: Int!, idNumber: String!, name: String!, phoneNumber: String!, room: Int!, sex: Sex!, unit: Int!): User
  createUser(data: UserCreateInput!): User!
  createWorker(idNumber: String!, name: String!, password: String!, phoneNumber: String!): User
  deleteActivity(where: ActivityWhereUniqueInput!): Activity
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteAdvice(where: AdviceWhereUniqueInput!): Advice
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyActivities(where: ActivityWhereInput): BatchPayload!
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  deleteManyAdvices(where: AdviceWhereInput): BatchPayload!
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteUser(where: UserWhereUniqueInput!): User
  login(idNumber: String, password: String): AuthPayload
  signup(idNumber: String, name: String, password: String, phoneNumber: String, role: Role!): AuthPayload
  singleUpload(file: Upload!): File
  updateActivity(data: ActivityUpdateInput!, where: ActivityWhereUniqueInput!): Activity
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateAdvice(data: AdviceUpdateInput!, where: AdviceWhereUniqueInput!): Advice
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyActivities(data: ActivityUpdateManyMutationInput!, where: ActivityWhereInput): BatchPayload!
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  updateManyAdvices(data: AdviceUpdateManyMutationInput!, where: AdviceWhereInput): BatchPayload!
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateResident(building: Int, id: ID!, idNumber: String, name: String, phoneNumber: String, room: Int, sex: Sex, unit: Int): User
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateWorker(id: ID!, idNumber: String!, name: String!, password: String!, phoneNumber: String!): User
  upsertActivity(create: ActivityCreateInput!, update: ActivityUpdateInput!, where: ActivityWhereUniqueInput!): Activity!
  upsertAddress(create: AddressCreateInput!, update: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address!
  upsertAdvice(create: AdviceCreateInput!, update: AdviceUpdateInput!, where: AdviceWhereUniqueInput!): Advice!
  upsertComment(create: CommentCreateInput!, update: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  upsertFile(create: FileCreateInput!, update: FileUpdateInput!, where: FileWhereUniqueInput!): File!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

enum MutationType {
  CREATED
  DELETED
  UPDATED
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  activities(after: String, before: String, first: Int, last: Int, orderBy: ActivityOrderByInput, skip: Int, where: ActivityWhereInput): [Activity!]!
  activitiesConnection(after: String, before: String, first: Int, last: Int, orderBy: ActivityOrderByInput, skip: Int, where: ActivityWhereInput): ActivityConnection!
  activity(where: ActivityWhereUniqueInput!): Activity
  address(where: AddressWhereUniqueInput!): Address
  addresses(after: String, before: String, first: Int, last: Int, orderBy: AddressOrderByInput, skip: Int, where: AddressWhereInput): [Address!]!
  addressesConnection(after: String, before: String, first: Int, last: Int, orderBy: AddressOrderByInput, skip: Int, where: AddressWhereInput): AddressConnection!
  advice(where: AdviceWhereUniqueInput!): Advice
  advices(after: String, before: String, first: Int, last: Int, orderBy: AdviceOrderByInput, skip: Int, where: AdviceWhereInput): [Advice!]!
  advicesConnection(after: String, before: String, first: Int, last: Int, orderBy: AdviceOrderByInput, skip: Int, where: AdviceWhereInput): AdviceConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderByInput, skip: Int, where: CommentWhereInput): [Comment!]!
  commentsConnection(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderByInput, skip: Int, where: CommentWhereInput): CommentConnection!
  file(where: FileWhereUniqueInput!): File
  files(after: String, before: String, first: Int, last: Int, orderBy: FileOrderByInput, skip: Int, where: FileWhereInput): [File!]!
  filesConnection(after: String, before: String, first: Int, last: Int, orderBy: FileOrderByInput, skip: Int, where: FileWhereInput): FileConnection!
  me: User
  uploads: [File!]
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
}

enum Role {
  MANAGER
  RESIDENT
  WORKER
}

enum Sex {
  FEMALE
  MALE
}

enum Status {
  APPROVED
  PENDING
  REJECTED
}

type Subscription {
  comment(adviceId: ID!): CommentSubscriptionPayload
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  activities(after: String, before: String, first: Int, last: Int, orderBy: ActivityOrderByInput, skip: Int, where: ActivityWhereInput): [Activity!]
  address: Address
  advices(after: String, before: String, first: Int, last: Int, orderBy: AdviceOrderByInput, skip: Int, where: AdviceWhereInput): [Advice!]
  comments(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderByInput, skip: Int, where: CommentWhereInput): [Comment!]
  id: ID!
  idNumber: String!
  name: String!
  password: String
  phoneNumber: String!
  role: Role!
  sex: Sex
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  activities: ActivityCreateManyWithoutOwnerInput
  address: AddressCreateOneWithoutUsersInput
  advices: AdviceCreateManyWithoutOwnerInput
  comments: CommentCreateManyWithoutOwnerInput
  id: ID
  idNumber: String!
  name: String!
  password: String
  phoneNumber: String!
  role: Role!
  sex: Sex
}

input UserCreateManyWithoutAddressInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutAddressInput!]
}

input UserCreateOneWithoutActivitiesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutActivitiesInput
}

input UserCreateOneWithoutAdvicesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutAdvicesInput
}

input UserCreateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateWithoutActivitiesInput {
  address: AddressCreateOneWithoutUsersInput
  advices: AdviceCreateManyWithoutOwnerInput
  comments: CommentCreateManyWithoutOwnerInput
  id: ID
  idNumber: String!
  name: String!
  password: String
  phoneNumber: String!
  role: Role!
  sex: Sex
}

input UserCreateWithoutAddressInput {
  activities: ActivityCreateManyWithoutOwnerInput
  advices: AdviceCreateManyWithoutOwnerInput
  comments: CommentCreateManyWithoutOwnerInput
  id: ID
  idNumber: String!
  name: String!
  password: String
  phoneNumber: String!
  role: Role!
  sex: Sex
}

input UserCreateWithoutAdvicesInput {
  activities: ActivityCreateManyWithoutOwnerInput
  address: AddressCreateOneWithoutUsersInput
  comments: CommentCreateManyWithoutOwnerInput
  id: ID
  idNumber: String!
  name: String!
  password: String
  phoneNumber: String!
  role: Role!
  sex: Sex
}

input UserCreateWithoutCommentsInput {
  activities: ActivityCreateManyWithoutOwnerInput
  address: AddressCreateOneWithoutUsersInput
  advices: AdviceCreateManyWithoutOwnerInput
  id: ID
  idNumber: String!
  name: String!
  password: String
  phoneNumber: String!
  role: Role!
  sex: Sex
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  idNumber_ASC
  idNumber_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  role_ASC
  role_DESC
  sex_ASC
  sex_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  idNumber: String
  idNumber_contains: String
  idNumber_ends_with: String
  idNumber_gt: String
  idNumber_gte: String
  idNumber_in: [String!]
  idNumber_lt: String
  idNumber_lte: String
  idNumber_not: String
  idNumber_not_contains: String
  idNumber_not_ends_with: String
  idNumber_not_in: [String!]
  idNumber_not_starts_with: String
  idNumber_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  phoneNumber: String
  phoneNumber_contains: String
  phoneNumber_ends_with: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_not: String
  phoneNumber_not_contains: String
  phoneNumber_not_ends_with: String
  phoneNumber_not_in: [String!]
  phoneNumber_not_starts_with: String
  phoneNumber_starts_with: String
  role: Role
  role_in: [Role!]
  role_not: Role
  role_not_in: [Role!]
  sex: Sex
  sex_in: [Sex!]
  sex_not: Sex
  sex_not_in: [Sex!]
}

input UserUpdateInput {
  activities: ActivityUpdateManyWithoutOwnerInput
  address: AddressUpdateOneWithoutUsersInput
  advices: AdviceUpdateManyWithoutOwnerInput
  comments: CommentUpdateManyWithoutOwnerInput
  idNumber: String
  name: String
  password: String
  phoneNumber: String
  role: Role
  sex: Sex
}

input UserUpdateManyDataInput {
  idNumber: String
  name: String
  password: String
  phoneNumber: String
  role: Role
  sex: Sex
}

input UserUpdateManyMutationInput {
  idNumber: String
  name: String
  password: String
  phoneNumber: String
  role: Role
  sex: Sex
}

input UserUpdateManyWithoutAddressInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutAddressInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutAddressInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateOneRequiredWithoutActivitiesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutActivitiesInput
  update: UserUpdateWithoutActivitiesDataInput
  upsert: UserUpsertWithoutActivitiesInput
}

input UserUpdateOneRequiredWithoutAdvicesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutAdvicesInput
  update: UserUpdateWithoutAdvicesDataInput
  upsert: UserUpsertWithoutAdvicesInput
}

input UserUpdateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateWithoutActivitiesDataInput {
  address: AddressUpdateOneWithoutUsersInput
  advices: AdviceUpdateManyWithoutOwnerInput
  comments: CommentUpdateManyWithoutOwnerInput
  idNumber: String
  name: String
  password: String
  phoneNumber: String
  role: Role
  sex: Sex
}

input UserUpdateWithoutAddressDataInput {
  activities: ActivityUpdateManyWithoutOwnerInput
  advices: AdviceUpdateManyWithoutOwnerInput
  comments: CommentUpdateManyWithoutOwnerInput
  idNumber: String
  name: String
  password: String
  phoneNumber: String
  role: Role
  sex: Sex
}

input UserUpdateWithoutAdvicesDataInput {
  activities: ActivityUpdateManyWithoutOwnerInput
  address: AddressUpdateOneWithoutUsersInput
  comments: CommentUpdateManyWithoutOwnerInput
  idNumber: String
  name: String
  password: String
  phoneNumber: String
  role: Role
  sex: Sex
}

input UserUpdateWithoutCommentsDataInput {
  activities: ActivityUpdateManyWithoutOwnerInput
  address: AddressUpdateOneWithoutUsersInput
  advices: AdviceUpdateManyWithoutOwnerInput
  idNumber: String
  name: String
  password: String
  phoneNumber: String
  role: Role
  sex: Sex
}

input UserUpdateWithWhereUniqueWithoutAddressInput {
  data: UserUpdateWithoutAddressDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutActivitiesInput {
  create: UserCreateWithoutActivitiesInput!
  update: UserUpdateWithoutActivitiesDataInput!
}

input UserUpsertWithoutAdvicesInput {
  create: UserCreateWithoutAdvicesInput!
  update: UserUpdateWithoutAdvicesDataInput!
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsDataInput!
}

input UserUpsertWithWhereUniqueWithoutAddressInput {
  create: UserCreateWithoutAddressInput!
  update: UserUpdateWithoutAddressDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  activities_every: ActivityWhereInput
  activities_none: ActivityWhereInput
  activities_some: ActivityWhereInput
  address: AddressWhereInput
  advices_every: AdviceWhereInput
  advices_none: AdviceWhereInput
  advices_some: AdviceWhereInput
  AND: [UserWhereInput!]
  comments_every: CommentWhereInput
  comments_none: CommentWhereInput
  comments_some: CommentWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  idNumber: String
  idNumber_contains: String
  idNumber_ends_with: String
  idNumber_gt: String
  idNumber_gte: String
  idNumber_in: [String!]
  idNumber_lt: String
  idNumber_lte: String
  idNumber_not: String
  idNumber_not_contains: String
  idNumber_not_ends_with: String
  idNumber_not_in: [String!]
  idNumber_not_starts_with: String
  idNumber_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  phoneNumber: String
  phoneNumber_contains: String
  phoneNumber_ends_with: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_not: String
  phoneNumber_not_contains: String
  phoneNumber_not_ends_with: String
  phoneNumber_not_in: [String!]
  phoneNumber_not_starts_with: String
  phoneNumber_starts_with: String
  role: Role
  role_in: [Role!]
  role_not: Role
  role_not_in: [Role!]
  sex: Sex
  sex_in: [Sex!]
  sex_not: Sex
  sex_not_in: [Sex!]
}

input UserWhereUniqueInput {
  id: ID
  idNumber: String
  phoneNumber: String
}
